---
name: learn
model: sonnet
description: Capture knowledge from codebase exploration. Triggers on "learn how...", "document how...", "remember how...", "save knowledge about...".
---

# Learn

Capture codebase understanding as searchable knowledge. **What you learn once, Claude remembers forever.**

## Workflow

### Step 1: Recall — Search what we already know

Before exploring, check if knowledge already exists on this topic.

```bash
npx superintent knowledge search "<topic keywords>" --branch-auto --limit 3
```

**Semantic Search:** ≥0.45 relevant, ≥0.55 strong. Don't discard low scores.

**MANDATORY — Validate every result that has citations.** Do NOT skip this. Run validate for each knowledge entry returned:

```bash
npx superintent knowledge validate <id>
```

Run all validate calls in parallel (one per result). Then check each status:

- **valid** → file unchanged since knowledge was written, trust fully
- **changed** → source file has evolved — knowledge is likely still valid, use citations as navigation hints for Step 2
- **missing** → source file was deleted — knowledge may be about removed code, verify in Step 2

If strong matches exist → present them. `AskUserQuestion`: "Existing knowledge found. Still explore, or is this sufficient?" → Explore deeper | Sufficient

### Step 2: Explore — Understand the topic

Use Task tool with `subagent_type=Explore` to understand the topic.

**Parallel exploration:** For complex topics, run multiple Explore agents in parallel (one message, multiple Task calls) — e.g., explore architecture + explore patterns + explore usage. If knowledge from Step 1 conflicts with current state, current state wins — mention the conflict to the user.

Present findings conversationally as you go.

### Step 3: Compose & Save — Create the knowledge entry

Synthesize exploration findings into a knowledge entry. Highlight what's new vs what overlaps with existing knowledge from Step 1.

1. **Create via CLI** using JSON stdin. The `content` field holds the knowledge body. Use `\n` for newlines inside JSON strings
2. **ID is auto-generated by the CLI** (format: `KNOWLEDGE-YYYYMMDD-HHMMSSMMM`). If create fails → CLI returns specific field errors, fix the JSON and retry
3. **`fileHash` is auto-generated by the CLI** from the file path — only `path` is required in citations. The hash covers the entire file, not individual lines. Line numbers in `file:line` are navigation hints only

```bash
npx superintent knowledge create --stdin <<'KNOWLEDGE'
{"title": "{Title}", "namespace": "{namespace from CLAUDE.md}", "content": "{Using knowledge content formats from references}", "category": "{pattern|truth|principle|architecture|gotcha}", "source": "discovery", "confidence": {0-1}, "scope": "{new-only|backward-compatible|global|legacy-frozen}", "tags": ["{tag1}", "{tag2}"], "citations": [{"path": "{file.ts:lineNum}"}]}
KNOWLEDGE
```

3. **Report** the knowledge ID from CLI response

---

## Reference

### Confidence Defaults

| Category              | Default |
| --------------------- | ------- |
| Truth                 | 0.9     |
| Architecture / Gotcha | 0.85    |
| Pattern               | 0.8     |
| Principle             | 0.75    |

### Decision Scopes

**new-only** — Apply only to new code

**backward-compatible** — Apply without breaking existing behavior

**global** — Apply everywhere

**legacy-frozen** — Document only, don't change legacy code

Decision Scopes rule: Default to `new-only` for gotchas and patterns. Default to `global` for architecture and truths. Only use `global` if the knowledge applies to ALL code unconditionally, not just code in a specific area.

### Knowledge Content Formats

**Architecture:** `Component` / `Responsibility` / `Interfaces`

**Pattern:** `Why` / `When` / `Pattern`

**Truth:** `Fact` / `Verified`

**Principle:** `Rule` / `Why` / `Applies`

**Gotcha:** `Attempted` / `Failed Because` / `Instead` / `Symptoms`
