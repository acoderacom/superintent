---
name: spec
description: Write a spec for big features. Triggers on "spec", "plan feature", "big feature", "break down", "design system". Output is a saved spec — tickets come later via /ticket.
---

# Spec

Write a comprehensive spec and save it. **No tickets, no execution.** Tickets are created later via `/ticket` using the spec as input.

**When to use:**

- The intent is too big to hold in one ticket
- You need to think before building — scope is unclear, trade-offs exist
- Multiple modules, services, or concerns are involved
- You want to capture the vision and get alignment before any code

**When NOT to use:**

- You already know what to build → `/ticket`
- Single unit of work, even if complex → `/ticket`
- Quick fix, obvious change → `/task`

## Workflow

### Step 1: Recall — Search what we already know

Before asking questions, search the knowledge base — the source of truth.

```bash
npx superintent search "<user's intent keywords>" --branch main --limit 5
```

**Semantic Search:** ≥0.45 relevant, ≥0.55 strong. Don't discard low scores.

**Don't explore codebase yet** — knowledge informs exploration in Step 3.

### Step 2: Understand — Clarify the intent

If critical information is missing, ask before writing.

1. Restate the intent in one clear sentence
2. `AskUserQuestion`: up to 2-3 clarifying questions, 2-4 options each. Lead with recommended option.
3. Focus on:
   - **Scope boundaries** — what's in, what's out
   - **Key decisions** — choices that affect the feature
   - **Constraints** — dependencies, existing systems, rules that can't be broken

Don't over-ask. Capture the big picture — details get resolved per-ticket.

### Step 3: Explore — Gather context from codebase

1. **Explore relevant codebase** — use `subagent_type=Explore` understand current state, if knowledge found → start from patterns/files, else broad. **Parallel exploration:** For complex codebase, run multiple Explore agents in parallel
2. **Capture current state** — what exists today, how it works, what's the pain. This feeds into **Background**.
3. **Surface constraints** — technical/business rules, APIs, patterns, compatibility requirements. This feeds into **Constraints**.

Present findings conversationally as you go.

### Step 4: Compose & Save — Create the spec

Review full conversation context. Extract requirements, constraints, preferences. Synthesize into a structured spec. Adapt depth based on available information — not all sections required, include what's relevant.

1. **Create via CLI** using JSON stdin. The `content` field holds the full spec body as markdown. Use `\n` for newlines inside JSON strings.
2. **ID is auto-generated by the CLI** (format: `SPEC-YYYYMMDD-HHMMSSMMM`). If create fails → CLI returns specific field errors, fix the JSON and retry.

```bash
npx superintent spec create --stdin <<'SPEC'
{"title": "{Title}", "content": "## Summary\n\n{Concise overview (2-3 paragraphs). Core value proposition. Goal statement.}\n\n## Background\n\n{Current state — how things work today. What problem triggered this. Why now.}\n\n## User Stories\n\n{As a [role], I want [capability], so that [outcome]. 3-6 stories.}\n\n## Scope\n\n**In Scope:**\n\n* Item 1\n* Item 2\n\n**Out of Scope:**\n\n* Item 1\n* Item 2\n\n## Constraints\n\n{Technical and business rules. APIs, patterns, performance, compatibility.}\n\n## Key Decisions\n\n- {what} | reason: {why}\n\n## Risks & Mitigations\n\n- {what} | mitigation: {how}"}
SPEC
```

**Required sections in content:** Summary, Background, User Stories, Scope, Constraints.
**Include if relevant:** Key Decisions, Risks & Mitigations.
**Leave to `/ticket`:** Type, Change Class, Dependencies, detailed intent, task breakdowns.

### Step 5: Preview & Review — Review loop

1. **Call preview** to get the formatted markdown:

```bash
npx superintent spec preview <id>
```

The CLI returns `{"success": true, "data": {"id": "...", "preview": "..."}}` — render the `preview` field as markdown for the user.

2. `AskUserQuestion`: "How does this spec look?"
   - **Looks good** → proceed to Step 6
   - **Edit** → ask what to change, then update via JSON stdin and re-preview:

```bash
npx superintent spec update <id> --stdin <<'SPEC'
{"title": "{new title}", "content": "{updated content}"}
SPEC
```

Only include fields that changed. Repeat preview until approved.

### Step 6: Next steps

`AskUserQuestion`: "Ready to create tickets from this spec, or keep it for later?"
   - **Create tickets** → invoke the `/ticket` skill using `Skill` tool with `args: "<spec-id>"`
   - **Keep for later** → confirm saved, done
