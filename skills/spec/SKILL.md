---
name: spec
description: Write a spec for big features. Triggers on "spec", "plan feature", "big feature", "break down", "design system". Output is a saved spec — tickets come later via /ticket.
---

# Spec

Write a comprehensive spec and save it. **No tickets, no execution.** Tickets are created later via `/ticket` using the spec as input.

**When to use:**

- The intent is too big to hold in one ticket
- You need to think before building — scope is unclear, trade-offs exist
- Multiple modules, services, or concerns are involved
- You want to capture the vision and get alignment before any code

**When NOT to use:**

- You already know what to build → `/ticket`
- Single unit of work, even if complex → `/ticket`
- Quick fix, obvious change → `/task`

## Workflow

### Step 1: Recall — Search what we already know

Before asking questions, search the knowledge base — the source of truth.

```bash
npx superintent search "<user's intent keywords>" --branch main --limit 5
```

**Semantic Search:** ≥0.45 relevant, ≥0.55 strong. Don't discard low scores.

**Don't explore codebase yet** — knowledge informs exploration in Step 3.

### Step 2: Understand — Clarify the intent

If critical information is missing, ask before writing.

1. Restate the intent in one clear sentence
2. `AskUserQuestion`: up to 2-3 clarifying questions, 2-4 options each. Lead with recommended option.
3. Focus on:
   - **Scope boundaries** — what's in, what's out
   - **Key decisions** — choices that affect the feature
   - **Constraints** — dependencies, existing systems, rules that can't be broken

Don't over-ask. Capture the big picture — details get resolved per-ticket.

### Step 3: Explore — Gather context from codebase

1. **Explore relevant codebase** — use `subagent_type=Explore` understand current state, if knowledge found → start from patterns/files, else broad. **Parallel exploration:** For complex codebase, run multiple Explore agents in parallel
2. **Capture current state** — what exists today, how it works, what's the pain. This feeds into **Background**.
3. **Surface constraints** — technical/business rules, APIs, patterns, compatibility requirements. This feeds into **Constraints**.

Present findings conversationally as you go.

### Step 4: Compose — Write the spec

Review full conversation context. Extract requirements, constraints, preferences. Synthesize into a structured spec. Adapt depth based on available information — not all sections required, include what's relevant.

1. Output the spec using the template in Step 5
2. Highlight assumptions made due to missing information
3. `AskUserQuestion`: "Save this spec?"
   - **Save** → proceed to Step 5
   - **Revise** → adjust, re-present

### Step 5: Save — Persist the spec

1. **Create via CLI** using heredoc markdown (always `--stdin`, never JSON)
2. **ID is auto-generated by the CLI** (format: `SPEC-YYYYMMDD-HHMMSS`). Do NOT include an ID in the markdown — the CLI response contains the generated ID. If create fails → CLI returns specific field errors, fix the markdown and retry.

```bash
npx superintent spec create --stdin <<'SPEC'
# {Title}

## Summary

{Concise overview (2-3 paragraphs). Core value proposition. Goal statement.}

## Background

{Current state — how things work today. What problem triggered this. Why now. Context anyone needs before reasoning about this feature.}

## User Stories

{As a [role], I want [capability], so that [outcome]. 3-6 stories covering primary actors and key workflows.}

## Scope

**In Scope:**

* Item 1
* Item 2

**Out of Scope:**

* Item 1
* Item 2

## Constraints

{Technical and business rules the feature must operate within. APIs to integrate, patterns to follow, performance requirements, backward compatibility, platform limitations.}

## Key Decisions

- {what} | reason: {why}

## Risks & Mitigations

- {what} | mitigation: {how}
SPEC
```

**Required sections:** Summary, Background, User Stories, Scope, Constraints.
**Include if relevant:** Key Decisions, Risks & Mitigations.
**Leave to `/ticket`:** Type, Change Class, Dependencies, detailed intent, task breakdowns.

3. **Report** the spec ID from CLI response
4. `AskUserQuestion`: "Ready to create tickets from this spec, or keep it for later?"
   - **Create tickets** → invoke the `/ticket` skill using `Skill` tool with `args: "<spec-id>"`
   - **Keep for later** → confirm saved, done
