---
name: spec
description: Write a spec for big features. Triggers on "spec", "plan feature", "big feature", "break down", "design system". Output is a saved spec — tickets come later via /ticket.
---

# Spec

Write a comprehensive spec and save it. **No tickets, no execution.** Tickets are created later via `/ticket` using the spec as input.

**When to use:**

- The intent is too big to hold in one ticket
- You need to think before building — scope is unclear, trade-offs exist
- Multiple modules, services, or concerns are involved
- You want to capture the vision and get alignment before any code

**When NOT to use:**

- You already know what to build → `/ticket`
- Single unit of work, even if complex → `/ticket`
- Quick fix, obvious change → `/task`

## Workflow

### Step 1: Recall — Search what we already know

Before asking questions, search the knowledge base — the source of truth.

```bash
npx superintent search "<user's intent keywords>" --limit 5
```

**Semantic Search:** ≥0.45 relevant, ≥0.55 strong. Don't discard low scores.

**Don't explore codebase yet** — knowledge informs exploration in Step 3.

### Step 2: Understand — Clarify the intent

If critical information is missing, ask before writing.

1. Restate the intent in one clear sentence
2. `AskUserQuestion`: **one** clarifying question at a time, 2-4 options. Lead with recommended option.
3. Focus on:
   - **Scope boundaries** — what's in, what's out
   - **Key decisions** — choices that affect the work areas
   - **Constraints** — dependencies, existing systems

Don't over-ask. Capture the big picture — details get resolved per-ticket.

### Step 3: Explore — Gather context from codebase

1. **Explore relevant codebase** — use `subagent_type=Explore` understand current state, if knowledge found → start from patterns/files, else broad. **Parallel exploration:** For complex codebase, run multiple Explore agents in parallel
2. **Identify context** — modules, services, boundaries involved
3. **Surface constraints** — what exists, what to reuse, what to avoid

Present findings conversationally as you go.

### Step 4: Compose — Write the spec

Review full conversation context. Extract requirements, constraints, preferences. Synthesize into a structured spec. Adapt depth based on available information — not all sections required, include what's relevant.

1. Output the spec using the template in Step 5
2. Highlight assumptions made due to missing information
3. `AskUserQuestion`: "Save this spec?"
   - **Save** → proceed to Step 5
   - **Revise** → adjust, re-present

### Step 5: Save — Persist the spec

1. **Create via CLI** using heredoc markdown (always `--stdin`, never JSON)
2. **ID is auto-generated by the CLI** (format: `SPEC-YYYYMMDD-HHMMSS`). Do NOT include an ID in the markdown — the CLI response contains the generated ID. If create fails → CLI returns specific field errors, fix the markdown and retry.

```bash
npx superintent spec create --stdin <<'SPEC'
# {Title}

## Summary

{Concise overview (2-3 paragraphs). Core value proposition. Goal statement.}

## Scope

**In Scope:**

* Item 1
* Item 2

**Out of Scope:**

* Item 1
* Item 2

## Key Decisions

- decision: {what} | reason: {why}

## Work Areas

1. {Major chunk of work — name and one-line description}
2. {Next chunk}
3. {Next chunk}

Order: {natural sequence and parallelism, e.g. "1 first, then 2 and 3 in parallel"}

## Success Criteria

- {What "done" looks like for the whole feature}

## Risks & Mitigations

- risk: {what} | mitigation: {how}
SPEC
```

**Required sections:** Summary, Scope, Work Areas, Success Criteria.
**Include if relevant:** Key Decisions, Risks & Mitigations.
**Leave to `/ticket`:** Type, Change Class, Dependencies, detailed intent, task breakdowns.

3. **Report** the spec ID from CLI response
4. `AskUserQuestion`: "Ready to create tickets from this spec, or keep it for later?"
   - **Create tickets** → invoke the `/ticket` skill using `Skill` tool with `args: "<spec-id>"`
   - **Keep for later** → confirm saved, done
