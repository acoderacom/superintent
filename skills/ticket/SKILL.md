---
name: ticket
description: Create and execute development tickets. Triggers on "I want...", "Add/Build/Create...", ticket IDs (TICKET-*), spec IDs (SPEC-*), "create ticket", "work on", "fetch ticket", "get ticket".
---

# Ticket

Turn raw ideas into well-structured tickets through the Superintent loop.
The key insight: **past knowledge makes future tickets smarter**.

## Workflow

### Step 1: Recall — Search what we already know

Before asking questions, search the knowledge base — the source of truth.

```bash
npx superintent search "<user's intent keywords>" --limit 5
```

**Semantic Search:** ≥0.45 relevant, ≥0.55 strong. Don't discard low scores.

**Don't explore codebase yet** — knowledge informs exploration in Step 3.

### Step 2: Understand — Clarify the intent

1. Restate the intent in one clear sentence
2. `AskUserQuestion`: **one** clarifying question at a time, prefer multiple-choice
3. Focus on: purpose, scope, success criteria
4. Incorporate knowledge from Phase 1 into questions — offer informed choices, not blank ones

Be ready to go back and clarify if something doesn't make sense.
Stop when the intent is clear. If simple requests suggest `/task`.

### Step 3: Explore — Gather context from codebase

1. **Explore relevant codebase** — use `subagent_type=Explore` understand current state **Parallel exploration:** For complex codebase, run multiple Explore agents in parallel, if knowledge found → start from patterns/files, else broad.
2. **Identify context** — files, patterns, dependencies involved
3. **Surface constraints** — what to use/avoid (only if non-obvious from knowledge base)
4. **Assess change class**:
   - **A**: New isolated code, low risk
   - **B**: Touches multiple areas, moderate risk
   - **C**: Architectural/breaking, high risk
5. **State assumptions** — list and ask user to validate

Present findings conversationally as you go.

### Step 4: Compose — Write the ticket

1. **Create via CLI** using heredoc markdown (always `--stdin`, never JSON)
2. **ID is auto-generated by the CLI** (format: `TICKET-YYYYMMDD-HHMMSS`). Do NOT include an ID in the markdown — the CLI response contains the generated ID. If create fails → CLI returns specific field errors, fix the markdown and retry.

```bash
npx superintent ticket create --stdin <<'TICKET'
# {Title}

**Type:** {type}
**Intent:** {intent}
**Context:** {context}
**Constraints:**
- Use: {use constraints}
- Avoid: {avoid constraints}
**Assumptions:** {assumptions}
**Change Class:** {A|B|C} - {reason}

## Plan

**Files:** file1.ts, file2.ts

**Tasks → Steps:**
1. Task name
   - Step detail
2. Another task
   - Step detail

**DoD → Verification:**
- criterion → how to verify

**Decisions:**
- choice → reason

**Trade-offs:**
- considered: alternative | rejected: why not

**Irreversible Actions:**
- action description

**Edge Cases:**
- scenario description

**Rollback:**
- Reversibility: full|partial|none
- Step to undo
TICKET
```

3. **Report** the ticket ID
4. `AskUserQuestion`: "Want to start execution now, or keep it in backlog?"
   - If start → ### Step 5: Implementation

### Step 5: Implementation

1. Update ticket status to `In Progress`
2. For each task (respect dependency order):
   - `TaskUpdate` → `in_progress` → implement → `completed`
   - On failure → Failure Protocol
3. Use `TaskList` for next task

### Step 6: Review - Check The Result **MANDATORY**

1. Update ticket status to `In Review`
2. Run code checks (test, lint, typecheck, build)
3. On failure, assess severity:
   - Test/lint fixes only → fix and re-run
   - Reveals plan flaw → trigger Failure Protocol
4. `AskUserQuestion`: "Implementation complete. Please review." → Approve | Request changes
5. After approval: `npx superintent ticket update <id> --status "Done" --complete-all`

### Step 7: Extract - Knowledge Compound

Run the automatic extraction:
```bash
npx superintent extract <ticket-id>
```

This returns proposals across categories. But don't blindly accept — **think deeper**:

1. **What did we actually learn?** Not just what the ticket said, but what happened during execution
2. **What surprised us?** Unexpected findings are the most valuable knowledge
3. **What would we tell our future self?** The gotchas, the "I wish I knew this before"
4. **Does this reinforce or contradict existing knowledge?**

Check for existing knowledge that overlaps:
```bash
npx superintent search "<key concept from ticket>" --limit 5
```

Present each proposed knowledge entry to the user. For each one:

1. Show the category, title, content, confidence, and scope
2. Ask: **keep, edit, or skip?**
3. If existing knowledge overlaps — ask: **merge, update confidence, or skip as duplicate?**

Keep it conversational, one entry at a time.

For each approved entry

1. **Create via CLI** using heredoc markdown (always `--stdin`, never JSON)
2. **ID is auto-generated by the CLI** (format: `KNOWLEDGE-YYYYMMDD-HHMMSS`). Do NOT include an ID in the markdown — the CLI response contains the generated ID. If create fails → CLI returns specific field errors, fix the markdown and retry.

```bash
npx superintent knowledge create --stdin <<'KNOWLEDGE'
# {Title}

**Namespace:** {namespace} from CLAUDE.md
**Category:** {pattern|truth|principle|architecture|gotcha}
**Source:** ticket
**Origin Ticket:** {TICKET-ID}
**Origin Ticket Type:** {ticket type}
**Confidence:** {0-1}
**Scope:** {new-only|backward-compatible|global|legacy-frozen}
**Tags:** {comma-separated, kebab-case}

## Content

{Content using category template from references}
KNOWLEDGE
```

Report each created knowledge ID.

If extraction revealed that existing knowledge should be updated:

- **Increase confidence** of validated knowledge:
  `npx superintent knowledge update <id> --confidence 0.95`
- **Deactivate** disproven knowledge:
  `npx superintent knowledge deactivate <id>`

**Judgment: What's Worth Extracting?**

Not everything deserves a knowledge entry. Extract when:

- **Reusable** — will apply to future work, not a one-off detail
- **Non-obvious** — Claude wouldn't know this without being told
- **Validated** — actually tested/proven, not theoretical

Skip when:
- Generic best practice Claude already knows
- Highly specific to one ticket with no future relevance
- Already captured in existing knowledge

---

## Reference

### Failure Protocol

1. **Fixable without changing the plan?** → Fix it, continue.
2. **Plan itself wrong?** → Stop. `AskUserQuestion`: explain what failed. Options: Revise plan | Abort.
3. **Blocked on something external?** → Status `Blocked`. `AskUserQuestion`: describe blocker.

### Abort Protocol

When user says "stop" or execution reveals the ticket is wrong:

1. Stop in-progress work immediately
2. `AskUserQuestion`: "Abort this ticket?"
   - **Revert & close** → status `Abandoned`, note reason, user handles reverting files
   - **Pause & keep** → status `Paused`, note where execution stopped and why
   - **Pivot** → new ticket informed by what was learned, original marked `Superseded`
3. **Always** extract gotcha knowledge from failures (Step 7)

### Status Flow

`Backlog` → `In Progress` → `In Review` → `Done`

Extended: `Blocked` (waiting on external), `Paused` (stopped intentionally), `Abandoned` (aborted), `Superseded` (replaced by new ticket)

### Ticket Types

| Type     | Inferred From                             |
| -------- | ----------------------------------------- |
| feature  | add, create, build, implement, new        |
| bugfix   | fix, bug, error, broken, crash, fail      |
| refactor | refactor, restructure, clean up, optimize |
| docs     | document, readme, comment, explain        |
| chore    | deps, migrate, config, CI/CD              |
| test     | test, spec, coverage, e2e                 |

### Change Classes

| Class | Examples                                         | Action   |
| ----- | ------------------------------------------------ | -------- |
| A     | Single file, tests, docs (not in critical paths) | Auto     |
| B     | Cross-module, APIs, deps                         | Propose  |
| C     | Schema, auth, payments                           | Approval |

### Confidence Defaults

| Category              | Default |
| --------------------- | ------- |
| Truth                 | 0.9     |
| Architecture / Gotcha | 0.85    |
| Pattern               | 0.8     |
| Principle             | 0.75    |

### Decision Scopes

**new-only** — Apply only to new code

**backward-compatible** — Apply without breaking existing behavior

**global** — Apply everywhere

**legacy-frozen** — Document only, don't change legacy code

### Content Formats

**Architecture:** `Component` / `Responsibility` / `Interfaces`

**Pattern:** `Why` / `When` / `Pattern`

**Truth:** `Fact` / `Verified`

**Principle:** `Rule` / `Why` / `Applies`

**Gotcha:** `Attempted` / `Failed Because` / `Instead` / `Symptoms`
