---
name: ticket
description: Create and execute development tickets. Triggers on "I want...", "Add/Build/Create...", ticket IDs (TICKET-*), spec IDs (SPEC-*), "create ticket", "work on", "fetch ticket", "get ticket".
---

# Ticket

Turn raw ideas into well-structured tickets through the Superintent loop.
The key insight: **past knowledge makes future tickets smarter**.

## Workflow

### Step 1: Recall — Search what we already know

Before asking questions, search the knowledge base — the source of truth.

```bash
npx superintent knowledge search "<user's intent keywords>" --branch-auto --limit 3
```

**Semantic Search:** ≥0.45 relevant, ≥0.55 strong. Don't discard low scores.

**Validate every result with citations** — run once per entry, all in parallel.

```bash
npx superintent knowledge validate <id>
```

Check each status:

- **valid** → file unchanged since knowledge was written, trust fully
- **changed** → source file has evolved — knowledge is likely still valid
- **missing** → source file was deleted — knowledge may be about removed code, trigger **Knowledge Conflict Protocol**

Citations are provenance links, not validity proofs. `changed` is informational — only `missing` signals real concern.

**Don't explore codebase yet** — knowledge informs exploration in Step 3.

### Step 2: Understand — Clarify the intent

1. Restate the intent in one clear sentence
2. `AskUserQuestion`: **one** clarifying question at a time, prefer multiple-choice
3. Focus on: purpose, scope, success criteria
4. Incorporate knowledge from Step 1 into questions — offer informed choices, not blank ones

Be ready to go back and clarify if something doesn't make sense.
Stop when the intent is clear. For simple requests — suggest `/task`.

### Step 3: Explore — Gather context from codebase

1. **Explore relevant codebase** — use `subagent_type=Explore` to understand current state. For complex codebases, run multiple in parallel.
   - Use citations as navigation hints when knowledge found, otherwise explore broadly
   - When knowledge conflicts with current state, current state wins — trigger **Knowledge Conflict Protocol**
2. **Identify context** — files, patterns, dependencies involved
3. **Surface constraints** — what to use/avoid (only if non-obvious from knowledge base)
4. **Assess change class** — capture both class + reason:
   - **A**: New isolated code, low risk
   - **B**: Touches multiple areas, moderate risk
   - **C**: Architectural/breaking, high risk
5. **State assumptions** — list and ask user to validate

Present findings conversationally as you go.

### Step 4: Compose & Save — Create the ticket

1. **Create via CLI** using JSON stdin. Use `\n` for newlines inside JSON strings. The `plan` field is a structured JSON object matching TicketPlan.
2. **ID is auto-generated by the CLI** (format: `TICKET-YYYYMMDD-HHMMSSMMM`). If create fails → CLI returns specific field errors, fix the JSON and retry.

```bash
npx superintent ticket create --stdin <<'TICKET'
{"title": "{Title}", "type": "{type}", "intent": "{intent}", "context": "{context}", "constraints": {"use": ["{use1}", "{use2}"], "avoid": ["{avoid1}", "{avoid2}"]}, "assumptions": ["{assumption1}", "{assumption2}"], "changeClass": "{A|B|C}", "changeClassReason": "{reason}", "plan": {"files": ["{file1.ts}", "{file2.ts}"], "taskSteps": [{"task": "{Task name}", "steps": ["{Step detail}"]}], "dodVerification": [{"dod": "{criterion}", "verify": "{how to verify}"}], "decisions": [{"choice": "{choice}", "reason": "{reason}"}], "tradeOffs": [{"considered": "{alternative}", "rejected": "{why not}"}], "rollback": {"reversibility": "{full|partial|none}", "steps": ["{step to undo}"]}, "irreversibleActions": ["{action description}"], "edgeCases": ["{scenario description}"]}}
TICKET
```

### Step 5: Preview & Review — Review loop

**Change Class A → skip preview.** Report the ticket ID and go directly to Step 6.

**Change Class B/C → preview loop:**

1. **Call preview** to get the formatted markdown:

```bash
npx superintent ticket preview <id>
```

The CLI returns `{"success": true, "data": {"id": "...", "preview": "..."}}` — render the `preview` field as markdown for the user.

2. `AskUserQuestion`: "How does this ticket look?"
   - **Looks good** → proceed
   - **Request changes** → ask what to change, then update via JSON stdin and re-preview:

```bash
npx superintent ticket update <id> --stdin <<'TICKET'
{"title": "{new title}", "context": "{updated context}", "plan": {...}}
TICKET
```

Only include fields that changed. Repeat preview until approved.

**Change Class B/C after approval:**

`AskUserQuestion`: "Want to start execution now, or keep it in backlog?"

- If start → go to Step 6

### Step 6: Implementation — The work

1. Update ticket status to `In Progress`
2. For each task (respect dependency order):
   - `TaskUpdate` → `in_progress` → implement → `completed`
   - On failure → Failure Protocol
3. Use `TaskList` for next task

### Step 7: Review — Check the result (MANDATORY)

1. Update ticket status to `In Review`
2. Run build and code checks (test, lint, typecheck, build)
3. On failure, assess severity:
   - Test/lint fixes only → fix and re-run
   - Reveals plan flaw → trigger Failure Protocol
4. `AskUserQuestion`: "Implementation complete. Please review." → Approve | Request changes
5. After approval: `npx superintent ticket update <id> --status "Done" --complete-all`

### Step 8: Extract — The knowledge compound

Run the automatic extraction:

```bash
npx superintent knowledge extract <ticket-id>
```

This returns proposals across categories. But don't blindly accept — **think deeper**:

1. **What did we actually learn?** Not just what the ticket said, but what happened during execution
2. **What surprised us?** Unexpected findings are the most valuable knowledge
3. **What would we tell our future self?** The gotchas, the "I wish I knew this before"
4. **Does this reinforce or contradict existing knowledge?**

Check for existing knowledge that overlaps:

```bash
npx superintent knowledge search "<key concept from ticket>" --branch-auto --limit 3
```

Present each proposed knowledge entry to the user. For each one:

1. Show the category, title, content, confidence, and decision scopes
2. Ask: **keep, edit, or skip?**
3. If existing knowledge overlaps — ask: **merge, update confidence, or skip as duplicate?**

Keep it conversational, one entry at a time.

For each approved entry:

1. **Create via CLI** using JSON stdin. The `content` field holds the knowledge body. Use `\n` for newlines inside JSON strings
2. **ID is auto-generated by the CLI** (format: `KNOWLEDGE-YYYYMMDD-HHMMSSMMM`). If create fails → CLI returns specific field errors, fix the JSON and retry
3. **`fileHash` is auto-generated by the CLI** from the file path — only `path` is required in citations. The hash covers the entire file, not individual lines. Line numbers in `file:line` are navigation hints only

```bash
npx superintent knowledge create --stdin <<'KNOWLEDGE'
{"title": "{Title}", "namespace": "{namespace from CLAUDE.md}", "content": "{Using knowledge content formats from references}", "category": "{pattern|truth|principle|architecture|gotcha}", "source": "ticket", "originTicketId": "{TICKET-ID}", "originTicketType": "{ticket type}", "confidence": {0-1}, "scope": "{new-only|backward-compatible|global|legacy-frozen}", "tags": ["{tag1}", "{tag2}"], "citations": [{"path": "{file.ts:lineNum}"}]}
KNOWLEDGE
```

Report each created knowledge ID.

If extraction revealed that existing knowledge should be updated:

- **Increase confidence** of validated knowledge:
  `npx superintent knowledge update <id> --confidence 0.95`
- **Deactivate** disproven knowledge:
  `npx superintent knowledge deactivate <id>`
- **Update stale citations** — if cited files were modified during this ticket, update the knowledge entry with fresh citations (pass `path` only, CLI auto-generates `fileHash`):
  ```bash
  npx superintent knowledge update <id> --stdin <<'KNOWLEDGE'
  {"citations": [{"path": "file.ts:1"}, ...]}
  KNOWLEDGE
  ```

**Judgment: What's Worth Extracting?**

Not everything deserves a knowledge entry. Extract when:

- **Reusable** — will apply to future work, not a one-off detail
- **Non-obvious** — Claude wouldn't know this without being told
- **Validated** — actually tested/proven, not theoretical

Skip when:

- Generic best practice Claude already knows
- Highly specific to one ticket with no future relevance
- Already captured in existing knowledge

---

## Reference

### Failure Protocol

1. **Fixable without changing the plan?** → Fix it, continue
2. **Plan itself wrong?** → Stop. `AskUserQuestion`: explain what failed. Options: Revise plan | Abort
3. **Blocked on something external?** → Status `Blocked`. `AskUserQuestion`: describe blocker

### Knowledge Conflict Protocol

Triggered when **citation validation** (Step 1) finds missing citations (source files deleted), or when **exploration** (Step 3) reveals knowledge contradicts current codebase state:

1. **Use current state** for the task — never trust orphaned knowledge over code
2. **Tell the user** what conflicted — include citation validation results if available (e.g., "2/3 citations missing — source files were deleted")
3. `AskUserQuestion`: "Knowledge `<id>` may be outdated. What should we do?"
   - **Update** → update content to match current state via `npx superintent knowledge update <id> --stdin`
   - **Deactivate** → `npx superintent knowledge deactivate <id>`
   - **Ignore** → keep as-is, confidence will be adjusted by `recalculate` based on missing citations

### Abort Protocol

When user says "stop" or execution reveals the ticket is wrong:

1. Stop in-progress work immediately
2. `AskUserQuestion`: "Abort this ticket?"
   - **Revert & close** → status `Abandoned`, note reason, user handles reverting files
   - **Pause & keep** → status `Paused`, note where execution stopped and why
   - **Pivot** → new ticket informed by what was learned, original marked `Superseded`
3. **Always** extract gotcha knowledge from failures (Step 8)

### Status Flow

`Backlog` → `In Progress` → `In Review` → `Done`

Extended: `Blocked` (waiting on external), `Paused` (stopped intentionally), `Abandoned` (aborted), `Superseded` (replaced by new ticket)

### Ticket Types

| Type     | Inferred From                             |
| -------- | ----------------------------------------- |
| feature  | add, create, build, implement, new        |
| bugfix   | fix, bug, error, broken, crash, fail      |
| refactor | refactor, restructure, clean up, optimize |
| docs     | document, readme, comment, explain        |
| chore    | deps, migrate, config, CI/CD              |
| test     | test, spec, coverage, e2e                 |

### Change Classes

| Class | Examples                                         | Action   |
| ----- | ------------------------------------------------ | -------- |
| A     | Single file, tests, docs (not in critical paths) | Auto     |
| B     | Cross-module, APIs, deps                         | Propose  |
| C     | Schema, auth, payments                           | Approval |

### Confidence Defaults

| Category              | Default |
| --------------------- | ------- |
| Truth                 | 0.9     |
| Architecture / Gotcha | 0.85    |
| Pattern               | 0.8     |
| Principle             | 0.75    |

### Decision Scopes

**new-only** — Apply only to new code

**backward-compatible** — Apply without breaking existing behavior

**global** — Apply everywhere

**legacy-frozen** — Document only, don't change legacy code

Decision Scopes rule: Default to `new-only` for gotchas and patterns. Default to `global` for architecture and truths. Only use `global` if the knowledge applies to ALL code unconditionally, not just code in a specific area.

### Knowledge Content Formats

**Architecture:** `Component` / `Responsibility` / `Interfaces`

**Pattern:** `Why` / `When` / `Pattern`

**Truth:** `Fact` / `Verified`

**Principle:** `Rule` / `Why` / `Applies`

**Gotcha:** `Attempted` / `Failed Because` / `Instead` / `Symptoms`